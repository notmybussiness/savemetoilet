import axios from 'axios';
import { placesService } from './placesService.js';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

/**
 * ÏÑúÏö∏Í≥µÍ≥µÎç∞Ïù¥ÌÑ∞ API ÎîîÎ≤ÑÍπÖ ÏãúÏä§ÌÖú
 */
const SeoulAPIDebugger = {
  /**
   * API ÌÇ§ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
   */
  validateApiKey: (apiKey) => {
    const validations = {
      exists: !!apiKey,
      length: apiKey ? apiKey.length : 0,
      format: apiKey ? /^[a-zA-Z0-9]+$/.test(apiKey) : false,
      expectedLength: apiKey ? apiKey.length >= 20 && apiKey.length <= 50 : false
    };

    console.log('üîç API Key Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨:', {
      key: apiKey ? `${apiKey.substring(0, 6)}...${apiKey.slice(-4)}` : 'NULL',
      ...validations
    });

    return validations;
  },

  /**
   * API ÏùëÎãµ ÏÉÅÌÉú Î∂ÑÏÑù
   */
  analyzeResponse: (response, error = null) => {
    if (error) {
      console.error('‚ùå Seoul API Ïò§Î•ò Î∂ÑÏÑù:', {
        message: error.message,
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        config: {
          url: error.config?.url,
          method: error.config?.method,
          headers: error.config?.headers
        }
      });
      return { success: false, error: error.message };
    }

    if (response?.data?.SearchPublicToiletPOIService) {
      const service = response.data.SearchPublicToiletPOIService;
      console.log('‚úÖ Seoul API ÏùëÎãµ ÏÑ±Í≥µ:', {
        list_total_count: service.list_total_count,
        result_code: service.RESULT?.CODE,
        result_message: service.RESULT?.MESSAGE,
        row_count: service.row?.length || 0
      });
      return { success: true, data: service };
    } else {
      console.error('‚ö†Ô∏è ÏòàÏÉÅÏπò Î™ªÌïú ÏùëÎãµ Íµ¨Ï°∞:', response?.data);
      return { success: false, error: 'Unexpected response structure' };
    }
  },

  /**
   * ÏùºÎ∞òÏ†ÅÏù∏ Seoul API Ïò§Î•ò Ìï¥Í≤∞Ï±Ö Ï†úÏïà
   */
  suggestSolution: (error) => {
    const solutions = {
      401: {
        problem: 'API ÌÇ§ Ïù∏Ï¶ù Ïã§Ìå®',
        solutions: [
          '1. API ÌÇ§ Ïû¨Î∞úÍ∏â (https://data.seoul.go.kr/)',
          '2. ÌôòÍ≤ΩÎ≥ÄÏàò VITE_SEOUL_API_KEY ÌôïÏù∏',
          '3. API ÌÇ§ ÌòïÏãù Í≤ÄÏ¶ù (ÏòÅÎ¨∏, Ïà´ÏûêÎßå ÌóàÏö©)'
        ]
      },
      403: {
        problem: 'ÏÑúÎπÑÏä§ ÏÇ¨Ïö© Í∂åÌïú ÏóÜÏùå',
        solutions: [
          '1. ÏÑúÏö∏Í≥µÍ≥µÎç∞Ïù¥ÌÑ∞ Ìè¨ÌÑ∏ÏóêÏÑú ÏÑúÎπÑÏä§ Ïã†Ï≤≠ ÌôïÏù∏',
          '2. API ÌÇ§ ÌôúÏÑ±Ìôî ÏÉÅÌÉú ÌôïÏù∏',
          '3. ÏùºÏùº ÏöîÏ≤≠ ÌïúÎèÑ Ï¥àÍ≥º Ïó¨Î∂Ä ÌôïÏù∏'
        ]
      },
      404: {
        problem: 'ÏÑúÎπÑÏä§ URL Ïò§Î•ò',
        solutions: [
          '1. ÏÑúÎπÑÏä§Î™Ö ÌôïÏù∏: SearchPublicToiletPOIService',
          '2. URL Íµ¨Ï°∞ Ïû¨ÌôïÏù∏',
          '3. API Î≤ÑÏ†Ñ ÌôïÏù∏'
        ]
      },
      500: {
        problem: 'ÏÑúÎ≤Ñ ÎÇ¥Î∂Ä Ïò§Î•ò',
        solutions: [
          '1. ÏöîÏ≤≠ Îß§Í∞úÎ≥ÄÏàò Í≤ÄÏ¶ù',
          '2. Îç∞Ïù¥ÌÑ∞ Î≤îÏúÑ Ï∂ïÏÜå (1/1000 ‚Üí 1/100)',
          '3. Ïû†Ïãú ÌõÑ Ïû¨ÏãúÎèÑ'
        ]
      }
    };

    const status = error.response?.status;
    const suggestion = solutions[status];
    
    if (suggestion) {
      console.log(`üí° Ìï¥Í≤∞Ï±Ö Ï†úÏïà (HTTP ${status}):`, suggestion);
    }
    
    return suggestion;
  }
};

/**
 * Enhanced toilet service with comprehensive Seoul API debugging
 */
export const toiletService = {
  /**
   * Ìñ•ÏÉÅÎêú ÏÑúÏö∏ Í≥µÍ≥µÌôîÏû•Ïã§ Í≤ÄÏÉâ (ÏôÑÏ†Ñ ÎîîÎ≤ÑÍπÖ Î≤ÑÏ†Ñ)
   */
  searchPublicToiletsWithDebug: async (lat, lng, radius) => {
    console.log('üöÄ Seoul API ÏöîÏ≤≠ ÏãúÏûë');
    
    try {
      const SEOUL_API_KEY = import.meta.env.VITE_SEOUL_API_KEY;
      
      // 1. API ÌÇ§ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
      const keyValidation = SeoulAPIDebugger.validateApiKey(SEOUL_API_KEY);
      if (!keyValidation.exists) {
        throw new Error('Seoul API KeyÍ∞Ä ÌôòÍ≤ΩÎ≥ÄÏàòÏóê ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§');
      }

      // 2. Îã§ÏñëÌïú URL Ìå®ÌÑ¥ ÏãúÎèÑ
      const urlPatterns = [
        // ÌëúÏ§Ä Ìå®ÌÑ¥ (ÌòÑÏû¨)
        `https://openapi.seoul.go.kr:8088/${SEOUL_API_KEY}/json/SearchPublicToiletPOIService/1/1000/`,
        
        // Ìè¨Ìä∏ ÏóÜÎäî Ìå®ÌÑ¥
        `https://openapi.seoul.go.kr/${SEOUL_API_KEY}/json/SearchPublicToiletPOIService/1/1000/`,
        
        // HTTP Ìå®ÌÑ¥ (CORS Ïö∞Ìöå ÏãúÎèÑ)
        `http://openapi.seoul.go.kr:8088/${SEOUL_API_KEY}/json/SearchPublicToiletPOIService/1/1000/`,
        
        // Ï∂ïÏÜåÎêú Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠
        `https://openapi.seoul.go.kr:8088/${SEOUL_API_KEY}/json/SearchPublicToiletPOIService/1/100/`
      ];

      console.log('üîó ÏãúÎèÑÌï† URL Ìå®ÌÑ¥Îì§:');
      urlPatterns.forEach((url, index) => {
        console.log(`   ${index + 1}. ${url.replace(SEOUL_API_KEY, '[API_KEY]')}`);
      });

      let lastError = null;

      // 3. URL Ìå®ÌÑ¥ ÏàúÏ∞® ÏãúÎèÑ
      for (let i = 0; i < urlPatterns.length; i++) {
        const seoulApiUrl = urlPatterns[i];
        console.log(`\nüì° Ìå®ÌÑ¥ ${i + 1} ÏãúÎèÑ Ï§ë...`);

        try {
          const startTime = Date.now();
          
          // ÏöîÏ≤≠ ÏÑ§Ï†ï (ÌÉÄÏûÑÏïÑÏõÉ Î∞è Ìó§Îçî ÏµúÏ†ÅÌôî)
          const config = {
            timeout: 10000, // 10Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
            headers: {
              'Accept': 'application/json',
              'User-Agent': 'SaveMeToilet/1.0'
            }
          };

          const response = await axios.get(seoulApiUrl, config);
          const responseTime = Date.now() - startTime;

          console.log(`‚è±Ô∏è ÏùëÎãµ ÏãúÍ∞Ñ: ${responseTime}ms`);

          // 4. ÏùëÎãµ Î∂ÑÏÑù
          const analysis = SeoulAPIDebugger.analyzeResponse(response);
          
          if (analysis.success) {
            const toilets = analysis.data.row || [];
            
            // 5. Îç∞Ïù¥ÌÑ∞ ÌíàÏßà Í≤ÄÏ¶ù
            console.log('üìä Îç∞Ïù¥ÌÑ∞ ÌíàÏßà Î∂ÑÏÑù:', {
              total_received: toilets.length,
              has_coordinates: toilets.filter(t => t.Y_WGS84 && t.X_WGS84).length,
              has_name: toilets.filter(t => t.FNAME).length,
              sample_data: toilets.slice(0, 2).map(t => ({
                name: t.FNAME,
                lat: t.Y_WGS84,
                lng: t.X_WGS84,
                address: t.ANAME
              }))
            });

            // 6. ÏßÄÎ¶¨Ï†Å ÌïÑÌÑ∞ÎßÅ Î∞è Í±∞Î¶¨ Í≥ÑÏÇ∞
            const processedToilets = toilets
              .filter(toilet => toilet.Y_WGS84 && toilet.X_WGS84) // Ï¢åÌëú ÏûàÎäî Í≤ÉÎßå
              .map((toilet) => {
                const distance = toiletService.calculateDistance(
                  lat, lng, toilet.Y_WGS84, toilet.X_WGS84
                );
                
                const urgencyMatch = distance < 300 ? 'high' : distance < 600 ? 'medium' : 'low';
                const distanceColor = distance <= 1000 ? '#DC2626' : '#2563EB';
                
                return {
                  id: `public_${toilet.POI_ID}`,
                  name: toilet.FNAME || 'Í≥µÍ≥µÌôîÏû•Ïã§',
                  type: 'public',
                  category: 'public',
                  quality_score: toilet.ANAME?.includes('ÎØºÍ∞Ñ') ? 2 : 1,
                  distance: Math.round(distance),
                  is_free: true,
                  coordinates: {
                    lat: parseFloat(toilet.Y_WGS84),
                    lng: parseFloat(toilet.X_WGS84)
                  },
                  address: toilet.FNAME + ' ÌôîÏû•Ïã§',
                  phone: null,
                  hours: '24ÏãúÍ∞Ñ',
                  facilities: {
                    disabled_access: true,
                    baby_changing: false,
                    separate_gender: true
                  },
                  urgency_match: urgencyMatch,
                  source: 'seoul_api',
                  color: distanceColor,
                  icon: 'üöΩ'
                };
              });

            console.log(`‚úÖ ÏÑ±Í≥µ! Ï≤òÎ¶¨Îêú ÌôîÏû•Ïã§: ${processedToilets.length}Í∞ú`);
            return processedToilets;

          } else {
            lastError = new Error(analysis.error);
            console.log(`‚ùå Ìå®ÌÑ¥ ${i + 1} Ïã§Ìå®, Îã§Ïùå Ìå®ÌÑ¥ ÏãúÎèÑ...`);
            continue;
          }

        } catch (error) {
          lastError = error;
          console.error(`‚ùå Ìå®ÌÑ¥ ${i + 1} ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò:`, error.message);
          
          // Ìï¥Í≤∞Ï±Ö Ï†úÏïà
          SeoulAPIDebugger.suggestSolution(error);
          
          // ÎßàÏßÄÎßâ Ìå®ÌÑ¥Ïù¥ ÏïÑÎãàÎ©¥ Í≥ÑÏÜç ÏãúÎèÑ
          if (i < urlPatterns.length - 1) {
            console.log('‚è≠Ô∏è Îã§Ïùå Ìå®ÌÑ¥ ÏãúÎèÑ Ï§ë...');
            continue;
          }
        }
      }

      // Î™®Îì† Ìå®ÌÑ¥ Ïã§Ìå® Ïãú
      throw new Error(`Î™®Îì† Seoul API Ìå®ÌÑ¥ Ïã§Ìå®. ÎßàÏßÄÎßâ Ïò§Î•ò: ${lastError?.message}`);

    } catch (error) {
      console.error('üí• Seoul API ÏôÑÏ†Ñ Ïã§Ìå®:', error);
      
      // ÏµúÏ¢Ö Ìï¥Í≤∞Ï±Ö Ï†úÏïà
      console.log('üîß ÏµúÏ¢Ö ÎîîÎ≤ÑÍπÖ Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏:');
      console.log('1. ‚úÖ API ÌÇ§ ÌôïÏù∏: https://data.seoul.go.kr/');
      console.log('2. ‚úÖ ÏÑúÎπÑÏä§ Ïã†Ï≤≠ ÏÉÅÌÉú ÌôïÏù∏');
      console.log('3. ‚úÖ ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÌôïÏù∏');
      console.log('4. ‚úÖ CORS Ï†ïÏ±Ö ÌôïÏù∏');
      console.log('5. ‚úÖ API ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏');
      
      return []; // Îπà Î∞∞Ïó¥ Î∞òÌôòÏúºÎ°ú Ïï± ÎèôÏûë Ïú†ÏßÄ
    }
  },

  // Í∏∞Ï°¥ Î©îÏÑúÎìúÎì§ Ïú†ÏßÄ...
  searchNearbyToilets: async (lat, lng, urgency = 'moderate', radius = 500, _filters = {}, placeTypes = ['starbucks']) => {
    try {
      const searchPromises = [];
      
      // ÎîîÎ≤ÑÍπÖ Î≤ÑÏ†Ñ ÏÇ¨Ïö©
      const publicToiletsPromise = toiletService.searchPublicToiletsWithDebug(lat, lng, radius);
      searchPromises.push(publicToiletsPromise);
      
      if (placeTypes && placeTypes.length > 0) {
        const commercialPlacesPromise = toiletService.searchCommercialPlaces(lat, lng, placeTypes, radius);
        searchPromises.push(commercialPlacesPromise);
      }
      
      const results = await Promise.allSettled(searchPromises);
      
      let publicToilets = [];
      let commercialPlaces = [];
      
      if (results[0].status === 'fulfilled') {
        publicToilets = results[0].value;
      } else {
        console.error('Public toilets search failed:', results[0].reason);
      }
      
      if (results.length > 1 && results[1].status === 'fulfilled') {
        commercialPlaces = results[1].value;
      } else if (results.length > 1) {
        console.error('Commercial places search failed:', results[1].reason);
      }
      
      const allToilets = [...publicToilets, ...commercialPlaces];
      const sortedToilets = toiletService.sortToiletsByUrgency(allToilets, lat, lng, urgency);
      
      return {
        success: true,
        data: {
          toilets: sortedToilets,
          total_count: sortedToilets.length,
          sources: {
            public: publicToilets.length,
            commercial: commercialPlaces.length
          }
        }
      };
      
    } catch (error) {
      console.error('Error searching toilets:', error);
      return {
        success: false,
        error: error.message,
        data: {
          toilets: [],
          total_count: 0,
          sources: {}
        }
      };
    }
  },

  /**
   * Í∏∞Ï°¥ ÏÑúÏö∏ API Í≤ÄÏÉâ (Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
   */
  searchPublicToilets: async (lat, lng, radius) => {
    return await toiletService.searchPublicToiletsWithDebug(lat, lng, radius);
  },

  searchCommercialPlaces: async (lat, lng, placeTypes, radius) => {
    try {
      const places = await placesService.searchCommercialPlaces(lat, lng, placeTypes, radius);
      return places;
    } catch (error) {
      console.error('Error searching commercial places:', error);
      return [];
    }
  },

  sortToiletsByUrgency: (toilets, userLat, userLng, urgency) => {
    return toilets.map(toilet => ({
      ...toilet,
      urgency_score: toiletService.calculateUrgencyScore(toilet, userLat, userLng, urgency)
    })).sort((a, b) => b.urgency_score - a.urgency_score);
  },

  calculateDistance: (lat1, lng1, lat2, lng2) => {
    const R = 6371000; // Earth's radius in meters
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = 
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
      Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  },

  searchByLocation: async (query, urgency = 'moderate', radius = 1000) => {
    try {
      const location = await placesService.searchLocation(query);
      if (location) {
        return await toiletService.searchNearbyToilets(
          location.lat, 
          location.lng, 
          urgency, 
          radius
        );
      }
      return { success: false, error: 'Location not found' };
    } catch (error) {
      console.error('Error searching by location:', error);
      throw error;
    }
  },

  savePreferences: (preferences) => {
    try {
      localStorage.setItem('toiletapp_preferences', JSON.stringify({
        ...preferences,
        lastUpdated: new Date().toISOString()
      }));
      return { success: true };
    } catch (error) {
      console.error('Error saving preferences:', error);
      return { success: false, error: error.message };
    }
  },

  loadPreferences: () => {
    try {
      const saved = localStorage.getItem('toiletapp_preferences');
      return saved ? JSON.parse(saved) : null;
    } catch (error) {
      console.error('Error loading preferences:', error);
      return null;
    }
  },

  calculateUrgencyScore: (toilet, userLat, userLng, urgency) => {
    const distance = toilet.distance || 0;
    const quality = toilet.quality_score || 1;
    
    let distanceWeight, qualityWeight;
    
    switch (urgency) {
      case 'emergency':
        distanceWeight = 0.9;
        qualityWeight = 0.1;
        break;
      case 'moderate':
        distanceWeight = 0.6;
        qualityWeight = 0.4;
        break;
      case 'relaxed':
        distanceWeight = 0.3;
        qualityWeight = 0.7;
        break;
      default:
        distanceWeight = 0.6;
        qualityWeight = 0.4;
    }
    
    const distanceScore = Math.max(0, 1000 - distance);
    const qualityScore = quality * 100;
    
    return (distanceScore * distanceWeight) + (qualityScore * qualityWeight);
  },

  getQualityDescription: (score) => {
    if (score >= 3) return { level: '‚≠ê‚≠ê‚≠ê ÌîÑÎ¶¨ÎØ∏ÏóÑ', color: 'success' };
    if (score >= 2) return { level: '‚≠ê‚≠ê ÌëúÏ§Ä', color: 'warning' };
    return { level: '‚≠ê Í∏∞Î≥∏', color: 'secondary' };
  },

  getUrgencyConfig: (level) => {
    const configs = {
      emergency: {
        label: 'üî¥ ÏßÑÏßú Í∏âÌï¥Ïöî!',
        radius: 300,
        color: 'danger',
        description: 'Í∞ÄÏû• Í∞ÄÍπåÏö¥ Í≥≥ Ïö∞ÏÑ†',
        placeTypes: ['starbucks', 'twosome', 'ediya']
      },
      moderate: {
        label: 'üü° Ï¢Ä Í∏âÌï¥Ïöî',
        radius: 500,
        color: 'warning',
        description: 'Í±∞Î¶¨ÏôÄ ÌíàÏßà Í∑†Ìòï',
        placeTypes: ['starbucks', 'twosome', 'ediya', 'cafe']
      },
      relaxed: {
        label: 'üü¢ Ïó¨Ïú†ÏûàÏñ¥Ïöî',
        radius: 1000,
        color: 'success',
        description: 'Íπ®ÎÅóÌïú Í≥≥ Ïö∞ÏÑ†',
        placeTypes: ['starbucks', 'twosome', 'ediya', 'cafe', 'department_store']
      }
    };
    
    return configs[level] || configs.moderate;
  },

  getCommercialPlaceTypes: () => {
    return placesService.getAvailablePlaceTypes();
  },

  getSearchStats: (toilets) => {
    const stats = {
      total: toilets.length,
      by_type: {},
      by_urgency: { high: 0, medium: 0, low: 0 },
      by_source: {},
      average_distance: 0,
      quality_distribution: { high: 0, medium: 0, low: 0 }
    };

    toilets.forEach(toilet => {
      stats.by_type[toilet.type] = (stats.by_type[toilet.type] || 0) + 1;
      stats.by_urgency[toilet.urgency_match] = (stats.by_urgency[toilet.urgency_match] || 0) + 1;
      stats.by_source[toilet.source] = (stats.by_source[toilet.source] || 0) + 1;
    });

    if (toilets.length > 0) {
      stats.average_distance = Math.round(
        toilets.reduce((sum, toilet) => sum + toilet.distance, 0) / toilets.length
      );
    }

    toilets.forEach(toilet => {
      if (toilet.quality_score >= 3) stats.quality_distribution.high++;
      else if (toilet.quality_score >= 2) stats.quality_distribution.medium++;
      else stats.quality_distribution.low++;
    });

    return stats;
  }
};